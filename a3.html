<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, maximum-scale=1.0" />

    <title>Sam Roberts' HCDE 439 Physical Computing Page!</title>

    <link href="style.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <h1>Sam Roberts' Assignment 3: Input/Output!</h1>
    <div class="header">
      <img src="A3.gif" />
      <p>Here is all the documentation Input/Output! This assignment utilizes a voltage divider and 
        analogRead/Write to create a circuit which reacts to the enviroment around it. My circuit uses 
        a photoresistor to detect brightness. As it gets dimmer around the photoresistor the output of 
        the pins also decreases. The display shows 4, 3, or 9 (HCDE 439) depending on how dark it is around the 
        photoresistor.
      </p>
    </div>
    <hr>
    <img src="A3Schematic.png" />
    <p>
      This is the schemattic for the circuit. My circuit utilizes the a seven segment display to show numbers 
      but only six of the segments are needed to display 4, 3, and 9, so only 6 of the segments LEDs are 
      wired. A voltage divider is used as a means of getting readable input from the photoresistor. As it gets 
      darker around the photoresistor and its resisitance increases, the A0 pin reads lower values of voltage after the first resistor.
      For each of the red LEDs they are all wired in series with a 220 ohm resistor to limit the current to close to 20 mA 
      (3.2/0.02). All LEDs are grounded through the grounding prong of the seven segment display. <br>
      Below is an image of the circuit.
    </p>
    <img src="A3pic.jpg">
    <p>
      The button part of circuit receives voltage from power on the Arduino board. A blue wire branches
      off after the button into pin 2, and a black wire goes to ground placed after a resistor. For the
      three LEDs, they are all connected to either pin 3, 4, or 10 by a red wire. They are in line with
      either a 220 ohm or 100 ohm resistor (depending on the voltage drop of the LED) to reduce the current.
      All three LEDs are then connected to the blue grounding bar on the breadboard by black wires, 
      which is connected to the ground on the Arduino board.
    </p>
    <hr>
    <p>
      int bottom_mid = 9; // initialize pin to associated part of 7-segment display<br>
      int bottom_right = 6; // initialize pin to associated part of 7-segment display<br>
      int mid = 11; // initialize pin to associated part of 7-segment display<br>
      int top_right = 5; // initialize pin to associated part of 7-segment display<br>
      int top_left = 10; // initialize pin to associated part of 7-segment display<br>
      int top_mid = 3; // initialize pin to associated part of 7-segment display<br>
      int output = 0; // output value for pins<br>
      int senMax = 0; // max value of analogRead during calbration<br>
      int senMin = 1023; // min value of analogRead during calbration<br>
      int senVal = 0; // value read from sensor<br>
      int number_choose = 0; // Determines which number to show on display<br>
      <br>
      void setup() {<br>
        // put your setup code here, to run once:<br>
        pinMode(bottom_mid, OUTPUT); // Set 7 segment display pins to output<br>
        pinMode(bottom_right, OUTPUT); // Set 7 segment display pins to output<br>
        pinMode(mid, OUTPUT); // Set 7 segment display pins to output<br>
        pinMode(top_right, OUTPUT); // Set 7 segment display pins to output<br>
        pinMode(top_left, OUTPUT); // Set 7 segment display pins to output<br>
        pinMode(top_mid, OUTPUT); // Set 7 segment display pins to output<br>
        Serial.begin(9600); // Begin serial to print to serial monitor<br>
        Serial.println("Start"); // Print start when calibration begins<br>
        while (millis() < 5000) { // For 5 sec after bootup<br>
          senVal = analogRead(A0); // Read value from voltage divider<br>
          if (senVal > senMax) { // Checks if value is max yet detected<br>
            senMax = senVal; // Sets max recored value to senor value<br>
          }<br>
          if (senVal < senMin) { // Checks if value is min yet detected<br>
            senMin = senVal; // Sets min recored value to senor value<br>
          }<br>
        }<br>
        senMin += 10; // Adds 10 max to cushion to value to make sure can turn all the way off<br>
        senMax -= 10; // Subtracts 10 min to cushion to value to make sure can turn all the way on<br>
        Serial.println("End"); // Print end when calibration ends<br>
      }<br>
      <br>
      void loop() {<br>
        // put your main code here, to run repeatedly:<br>
        number_choose = map(analogRead(A0), senMin, senMax, 0, 2); // Split range of recorded values into thirds<br>
        number_choose = constrain(number_choose, 0 ,2); // Constrains the output of mapping to between 0 and 2<br>
        output = map(analogRead(A0), senMin, senMax, 0, 255); // Maps output to 0 to 255 for analogWrite<br>
        if (number_choose == 2) { // If output is in the highest third, dispaly a 4<br>
          analogWrite(top_left, constrain(output, 0, 255)); // Light LEDs needed to display a 4 and set others to 0.<br>
          analogWrite(top_mid, 0); // Example of LED set to off<br>
          analogWrite(top_right, constrain(output, 0, 255)); // All lit LEDs are brighter with higher values read and cosntrained between 0 and 255<br>
          analogWrite(mid, constrain(output, 0, 255));<br>
          analogWrite(bottom_right, constrain(output, 0, 255));<br>
          analogWrite(bottom_mid, 0);<br>
        } else if (number_choose == 1) { // If output is in the middle third, dispaly a 3<br>
          analogWrite(top_left, 0); // Light and turn off LEDs to show a 3, lights behave the same as the 4<br>
          analogWrite(top_mid, constrain(output, 0, 255));<br>
          analogWrite(top_right, constrain(output, 0, 255));<br>
          analogWrite(mid, constrain(output, 0, 255));<br>
          analogWrite(bottom_right, constrain(output, 0, 255));<br>
          analogWrite(bottom_mid, constrain(output, 0, 255));<br>
        } else { // If output is in the middle third, dispaly a 9<br>
          analogWrite(top_left, constrain(output, 0, 255)); // Light and turn off LEDs to show a 9, lights behave the same as the 4 and 3<br>
          analogWrite(top_mid, constrain(output, 0, 255));<br>
          analogWrite(top_right, constrain(output, 0, 255));<br>
          analogWrite(mid, constrain(output, 0, 255));<br>
          analogWrite(bottom_right, constrain(output, 0, 255));<br>
          analogWrite(bottom_mid, 0);<br>
        }<br>
      }
    </p>
    <img src="A3.gif" class="center">
    <p><center>Final Circuit in action!</center></p>
    <hr>
    <hr>
    <p>
      1. For a voltage divider to work the varible resistor can be either R1 or R2. The equation
      for V out (R2 / (R1 + R2)) * V in shows that the voltage out is just the percentage of total resistance from R2 times 
      the input voltage. If we had 5 volts in and R1 of 50 and R2 of 50, the equation would give 50/100 * 5 = 2.5, which 
      makes sense since R2 is 50% of the resistance and V in is 5. If R1 is varible and becomes 100, R2 is now only 33%
      of the total resistance so V out = 1.65. Now if R2 is varible and becoems 100 it accounts for 66% of the resisitance
      and V out is 3.3. Either resistor can be varible but it important to keep track of how the relationship between the 
      readings and the resistance changes depending on which is varible.
    </p>
    <img src="fadeQ1.png" />
    <p>
      3. Changing the bits would change the range at which the values have to be mapped. Increasing the bits means that the 
      numbers can lay in a bigger range. So instead of map(analogRead(A0), 0, 1023, 0, 255) for 8 and 10 bit values, we would 
      have to write map(analogRead(A0), 0, 65536, 0, 1023) for 10 and 16 bit values.
    </p>
  </body>
</html>